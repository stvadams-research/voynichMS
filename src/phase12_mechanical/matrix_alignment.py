"""
Cross-Sectional Matrix Alignment

Tests if different thematic sections are generated by the same physical 
machine in different 'states' (permutations).
"""

from typing import List, Dict, Any, Tuple
from collections import defaultdict, Counter
import numpy as np

class MatrixAlignmentAnalyzer:
    """
    Computes and compares transition probability matrices between sections.
    """
    def build_section_matrix(self, lines: List[List[str]]) -> Dict[Tuple[str, int], Counter]:
        """Builds a transition model for a specific subset of lines."""
        model = defaultdict(Counter)
        for line in lines:
            for i in range(len(line) - 1):
                prev = line[i]
                curr = line[i+1]
                pos = i + 1
                model[(prev, pos)][curr] += 1
        return model

    def calculate_overlap(self, model_a: Dict, model_b: Dict) -> Dict[str, Any]:
        """Measures how many (context -> next) rules are shared."""
        contexts_a = set(model_a.keys())
        contexts_b = set(model_b.keys())
        shared_contexts = contexts_a.intersection(contexts_b)
        
        if not shared_contexts:
            return {"overlap_score": 0.0, "shared_count": 0}
            
        exact_matches = 0
        for ctx in shared_contexts:
            # Check if the top successor is the same
            if model_a[ctx].most_common(1)[0][0] == model_b[ctx].most_common(1)[0][0]:
                exact_matches += 1
                
        return {
            "overlap_score": exact_matches / len(shared_contexts),
            "shared_contexts": len(shared_contexts),
            "exact_matches": exact_matches
        }

    def test_permutation_alignment(self, model_a: Dict, model_b: Dict) -> Dict[str, Any]:
        """
        Tests if Model B is just a permuted version of Model A.
        (Simplified: check if transition distributions are statistically similar).
        """
        # We look at the 'Out-Degree' distributions
        out_a = sorted([sum(c.values()) for c in model_a.values()])
        out_b = sorted([sum(c.values()) for c in model_b.values()])
        
        # Trim to same size for correlation
        size = min(len(out_a), len(out_b))
        if size < 10: return {"correlation": 0.0}
        
        corr = np.corrcoef(out_a[:size], out_b[:size])[0, 1]
        
        return {
            "structural_correlation": float(corr),
            "is_mechanically_equivalent": bool(corr > 0.9)
        }
